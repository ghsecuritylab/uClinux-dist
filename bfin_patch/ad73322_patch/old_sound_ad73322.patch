This adds support for the AD73322 codec using the old sound framework

 sound/Kconfig                |    2 +
 sound/Makefile               |    1 +
 sound/blackfin/Kconfig       |   58 +++
 sound/blackfin/Makefile      |    7 +
 sound/blackfin/ad73322.c     | 1072 ++++++++++++++++++++++++++++++++++++++++++
 sound/blackfin/ad73322.h     |  135 ++++++
 sound/blackfin/bf53x_sport.c |  916 ++++++++++++++++++++++++++++++++++++
 sound/blackfin/bf53x_sport.h |  129 +++++
 8 files changed, 2320 insertions(+), 0 deletions(-)
 create mode 100644 sound/blackfin/Kconfig
 create mode 100644 sound/blackfin/Makefile
 create mode 100644 sound/blackfin/ad73322.c
 create mode 100644 sound/blackfin/ad73322.h
 create mode 100644 sound/blackfin/bf53x_sport.c
 create mode 100644 sound/blackfin/bf53x_sport.h

diff --git a/sound/Kconfig b/sound/Kconfig
index b3e53e6..7875107 100644
--- a/sound/Kconfig
+++ b/sound/Kconfig
@@ -96,6 +96,8 @@ source "sound/mips/Kconfig"
 
 source "sound/sh/Kconfig"
 
+source "sound/blackfin/Kconfig"
+
 # the following will depend on the order of config.
 # here assuming USB is defined before ALSA
 source "sound/usb/Kconfig"
diff --git a/sound/Makefile b/sound/Makefile
index ec467de..5a2a36b 100644
--- a/sound/Makefile
+++ b/sound/Makefile
@@ -7,6 +7,7 @@ obj-$(CONFIG_SOUND_PRIME) += oss/
 obj-$(CONFIG_DMASOUND) += oss/
 obj-$(CONFIG_SND) += core/ i2c/ drivers/ isa/ pci/ ppc/ arm/ sh/ synth/ usb/ \
 	sparc/ spi/ parisc/ pcmcia/ mips/ soc/ atmel/
+obj-$(CONFIG_SND) += blackfin/
 obj-$(CONFIG_SND_AOA) += aoa/
 
 # This one must be compilable even if sound is configured out
diff --git a/sound/blackfin/Kconfig b/sound/blackfin/Kconfig
new file mode 100644
index 0000000..111043a
--- /dev/null
+++ b/sound/blackfin/Kconfig
@@ -0,0 +1,58 @@
+#
+menu "ALSA Blackfin devices"
+	depends on SND && BLACKFIN
+
+config SND_BFIN_SPORT
+	int "Blackfin Audio SPORT port"
+	depends on SND_BFIN_AD73311
+	default 0
+	help
+	  Enter the Blackfin SPORT port to which your sound chip is connected
+	  acceptable values are 0 or 1
+
+config SND_BFIN_AD73322
+	tristate "Cascaded AD73322 Audio support for BF53x"
+	depends on SND && BLACKFIN
+	select SND_PCM
+	help
+	  Select this if you have AD73322 connected in cascade mode connected to SPORT0 ports
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called snd-ad73322.
+
+	  If unsure, say N.
+
+config SND_BFIN_SPORT
+	int "Blackfin Audio SPORT port"
+	depends on SND_BFIN_AD73322
+	default 2
+	help
+	  Enter the Blackfin SPORT port to which your sound chip is connected
+	  acceptable values are 0 ,1 or 2.Input 0 or 1 if, you have one card on SPORT0 or SPORT1,
+	  Input 2 if you have two card on SPORT0 and SPORT1. 	
+
+config SND_BFIN_AD73322_SPORT0_SE
+	int "PF pin for AD73322 Chip Select on SPORT0"
+	depends on SND_BFIN_AD73322
+	default 10
+	help
+	  Enter the GPIO used to control AD73322's SE pin. Acceptable
+	  values are 0 to 10
+
+config SND_BFIN_AD73322_SPORT1_SE
+	int "PF pin for AD73322 Chip Select on SPORT1"
+	depends on SND_BFIN_AD73322
+	default 14
+	help
+	  Enter the GPIO used to control AD73322's SE pin. Acceptable
+	  values are 11 to 14
+
+config SND_BFIN_AD73322_RESET
+	int "PF pin for AD73322 Chip Reset"
+	depends on SND_BFIN_AD73322
+	default 12
+	help
+	  Enter the GPIO used to control AD73322's RESET pin. Acceptable
+	  values are 0 to 14
+
+endmenu
diff --git a/sound/blackfin/Makefile b/sound/blackfin/Makefile
new file mode 100644
index 0000000..afea2e8
--- /dev/null
+++ b/sound/blackfin/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the blackfin 53x sport/spi connected ad1836
+#
+
+snd-ad73322-objs := ad73322.o bf53x_sport.o
+
+obj-$(CONFIG_SND_BFIN_AD73322)		+= snd-ad73322.o
diff --git a/sound/blackfin/ad73322.c b/sound/blackfin/ad73322.c
new file mode 100644
index 0000000..81b6353
--- /dev/null
+++ b/sound/blackfin/ad73322.c
@@ -0,0 +1,1072 @@
+/*
+ * File:         sound/blackfin/ad73322.c
+ * Based on:	 sound/blackfin/ad73311.c
+ * Author:       Cliff Cai <Cliff.Cai@analog.com>
+ *
+ * Created:      Tue May 06 2008
+ * Description:  Driver for AD73322 sound chip connected to bf53x sport
+ *
+ * Rev:          $Id: ad73322.c 4104 2008-05-06 06:51:48Z cliff $
+ *
+ * Modified:
+ *               Copyright 2008 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ *This driver supports up to 4 AD73322 connected in cascade mode.
+ */
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include <asm/blackfin.h>
+#include <asm/cacheflush.h>
+#include <asm/irq.h>
+#include <asm/gpio.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "ad73322.h"
+#include "bf53x_sport.h"
+
+#ifdef CONFIG_SND_DEBUG
+#define snd_printk_marker() snd_printk(KERN_INFO "%s\n", __FUNCTION__)
+#else
+#define snd_printk_marker()
+#endif
+
+#define GPIO_SPORT0_SE CONFIG_SND_BFIN_AD73322_SPORT0_SE
+#define GPIO_SPORT1_SE CONFIG_SND_BFIN_AD73322_SPORT1_SE
+#define GPIO_RESET CONFIG_SND_BFIN_AD73322_RESET
+
+#if CONFIG_SND_BFIN_SPORT == 0
+#define CONFIG_SND_BFIN_AD73322_SE CONFIG_SND_BFIN_AD73322_SPORT0_SE
+#define SPORT_IRQ_ERR	IRQ_SPORT0_ERROR
+#define SPORT_DMA_RX	CH_SPORT0_RX
+#define SPORT_DMA_TX	CH_SPORT0_TX
+#define bfin_write_SPORT_TCR1	bfin_write_SPORT0_TCR1
+#define bfin_read_SPORT_TCR1	bfin_read_SPORT0_TCR1
+#define bfin_write_SPORT_TCR2	bfin_write_SPORT0_TCR2
+#define bfin_write_SPORT_TX16	bfin_write_SPORT0_TX16
+#define bfin_read_SPORT_STAT	bfin_read_SPORT0_STAT
+#elif CONFIG_SND_BFIN_SPORT == 1
+#define CONFIG_SND_BFIN_AD73322_SE CONFIG_SND_BFIN_AD73322_SPORT1_SE
+#define SPORT_IRQ_ERR	IRQ_SPORT1_ERROR
+#define SPORT_DMA_RX	CH_SPORT1_RX
+#define SPORT_DMA_TX	CH_SPORT1_TX
+#define bfin_write_SPORT_TCR1	bfin_write_SPORT1_TCR1
+#define bfin_read_SPORT_TCR1	bfin_read_SPORT1_TCR1
+#define bfin_write_SPORT_TCR2	bfin_write_SPORT1_TCR2
+#define bfin_write_SPORT_TX16	bfin_write_SPORT1_TX16
+#define bfin_read_SPORT_STAT	bfin_read_SPORT1_STAT
+#elif CONFIG_SND_BFIN_SPORT == 2
+#define HAVE_TWO_CARDS
+#endif
+
+#ifdef HAVE_TWO_CARDS
+#define CARD_NUM 2
+#else
+#define CARD_NUM 1
+#endif
+
+static struct platform_device *device[CARD_NUM];
+
+#undef CONFIG_SND_DEBUG_CURRPTR  /* causes output every frame! */
+#define AD73322_BUF_SZ 0x40000
+#define PCM_BUFFER_MAX	0x10000	/* 64KB */
+#define FRAGMENT_SIZE_MIN	1024
+#define FRAGMENTS_MIN	2
+#define FRAGMENTS_MAX	16
+#define WORD_LENGTH	2
+
+#define DMA_BUFFER_BYTES	AD73322_BUF_SZ
+#define DMA_PERIOD_BYTES	(FRAGMENT_SIZE_MIN*4)
+#define DMA_PERIODS		(DMA_BUFFER_BYTES / DMA_PERIOD_BYTES)
+#define DMA_FRAME_BYTES		16
+#define DMA_BUFFER_FRAMES	(DMA_BUFFER_BYTES/DMA_FRAME_BYTES)
+#define DMA_PERIOD_FRAMES	(DMA_PERIOD_BYTES/DMA_FRAME_BYTES)
+
+#define DRIVER_NAME "AD73322"
+#define CHIP_NAME "Analog Devices AD73322"
+static char *pcm_name[8] = { "AD73322PCM0", "AD73322PCM1", "AD73322PCM2", "AD73322PCM3", "AD73322PCM4", "AD73322PCM5", "AD73322PCM6", "AD73322PCM7"};
+
+static unsigned int input_gain = 0x2;
+module_param(input_gain, uint, 0);
+MODULE_PARM_DESC(input_gain, "Input gain setting (0 <= input_gain <= 7)");
+
+static unsigned int output_gain = 0x2;
+module_param(output_gain, uint, 0);
+MODULE_PARM_DESC(output_gain, "Output gain setting (0 <= output_gain <= 7)");
+
+static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
+module_param_array(index, int, NULL, 0444);
+MODULE_PARM_DESC(index, "Index value for the AD73322 soundcard.");
+
+static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
+module_param_array(id, charp, NULL, 0444);
+MODULE_PARM_DESC(id, "ID string for the AD73322 soundcard.");
+
+static int enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;
+module_param_array(enable, bool, NULL, 0444);
+MODULE_PARM_DESC(enable, "Enable AD73322 soundcard.");
+
+static void snd_ad73322_startup(int index);
+static void snd_ad73322_stop(int index);
+
+static inline int get_cap_slotindex(int index)
+{
+	int slot_index = 6;
+	switch (index) {
+	case 0:
+		slot_index = 6;
+		break;
+	case 1:
+		slot_index = 7;
+		break;
+	case 2:
+		slot_index = 4;
+		break;
+	case 3:
+		slot_index = 5;
+		break;
+	case 4:
+		slot_index = 2;
+		break;
+	case 5:
+		slot_index = 3;
+		break;
+	case 6:
+		slot_index = 0;
+		break;
+	case 7:
+		slot_index = 1;
+		break;
+	}
+	return slot_index;
+}
+
+/*************************************************************
+ *                pcm methods
+ *************************************************************/
+
+static struct snd_pcm_hardware snd_ad73322_play_hw = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_RESUME),
+	.formats =          SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_8000,
+	.rate_min =         8000,
+	.rate_max =         8000,
+	.channels_min =     1,
+	.channels_max =     1,
+	.buffer_bytes_max = PCM_BUFFER_MAX,
+	.period_bytes_min = FRAGMENT_SIZE_MIN,
+	.period_bytes_max = PCM_BUFFER_MAX/2,
+	.periods_min =      FRAGMENTS_MIN,
+	.periods_max =      FRAGMENTS_MAX,
+};
+static struct snd_pcm_hardware snd_ad73322_cap_hw = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_RESUME),
+	.formats =          SNDRV_PCM_FMTBIT_S16_LE,
+	.rates =            SNDRV_PCM_RATE_8000,
+	.rate_min =         8000,
+	.rate_max =         8000,
+	.channels_min =     1,
+	.channels_max =     1,
+	.buffer_bytes_max = PCM_BUFFER_MAX,
+	.period_bytes_min = FRAGMENT_SIZE_MIN,
+	.period_bytes_max = PCM_BUFFER_MAX/2,
+	.periods_min =      FRAGMENTS_MIN,
+	.periods_max =      FRAGMENTS_MAX,
+};
+
+static int snd_ad73322_play_open(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	int index = substream->pcm->device;
+	/*device index from 0 to 7*/
+	if (snd_BUG_ON(index < 0 || index > 7))
+		return -EINVAL;
+	snd_printk_marker();
+	substream->runtime->hw = snd_ad73322_play_hw;
+	chip->tx_substreams[index].substream = substream;
+
+	return 0;
+}
+
+static int snd_ad73322_cap_open(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	int index = substream->pcm->device;
+
+	if (snd_BUG_ON(index < 0 || index > 7))
+		return -EINVAL;
+	snd_printk_marker();
+	substream->runtime->hw = snd_ad73322_cap_hw;
+	chip->rx_substreams[index].substream = substream;
+
+	return 0;
+}
+
+static int snd_ad73322_play_close(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	int i, slot_index;
+	int index = substream->pcm->device;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->tx_substreams[substream->pcm->device]);
+	slot_index = NUM_DEVICES_CHAIN-(index+1);
+	snd_printk_marker();
+	if (index >= 0 && index <= 7) {
+		sub_info->substream = NULL;
+		for (i=0; i < DMA_BUFFER_FRAMES; i++)
+			*((unsigned short *)chip->tx_dma_buf+i*8 + slot_index) = 0;
+	}
+	return 0;
+}
+
+static int snd_ad73322_cap_close(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	int slot_index, i;
+	int index = substream->pcm->device;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->rx_substreams[substream->pcm->device]);
+	slot_index  = get_cap_slotindex(index);
+	snd_printk_marker();
+	if (index >= 0 && index <= 7) {
+		sub_info->substream = NULL;
+		for (i=0; i < DMA_BUFFER_FRAMES; i++)
+			*((unsigned short *)chip->rx_dma_buf+i*8 + slot_index) = 0;
+	}
+	return 0;
+}
+
+static int snd_ad73322_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params* hwparams)
+{	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	snd_printk_marker();
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		substream->runtime->dma_area = chip->tx_dma_buf;
+		substream->runtime->dma_addr = (unsigned int)chip->tx_dma_buf;
+		substream->runtime->dma_bytes = AD73322_BUF_SZ;
+	} else {
+		substream->runtime->dma_area = chip->rx_dma_buf;
+		substream->runtime->dma_addr = (unsigned int)chip->rx_dma_buf;
+		substream->runtime->dma_bytes = AD73322_BUF_SZ;
+	}
+	return 0;
+}
+
+static int snd_ad73322_hw_free(struct snd_pcm_substream *substream)
+{
+	snd_printk_marker();
+	substream->runtime->dma_area = NULL;
+	substream->runtime->dma_addr = 0;
+	substream->runtime->dma_bytes = 0;
+
+	return 0;
+}
+
+static int snd_ad73322_play_pre(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->tx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+
+	if (snd_BUG_ON(index < 0 || index > 7 || !sub_info))
+		return -EINVAL;
+	sub_info->period_frames = runtime->period_size;
+	sub_info->periods = runtime->periods;
+	sub_info->buffer_frames = runtime->buffer_size;
+	sub_info->frame_bytes = runtime->frame_bits / 8;
+	sub_info->dma_inter_pos = 0;
+	sub_info->dma_last_pos = 0;
+	sub_info->dma_pos_base = 0;
+	sub_info->next_inter_pos = sub_info->period_frames;
+	sub_info->data_count = 0;
+	sub_info->data_pos_base = 0;
+	sub_info->boundary = DMA_BUFFER_FRAMES * sub_info->buffer_frames;
+
+	while (sub_info->boundary * 2 <= (LONG_MAX - DMA_BUFFER_FRAMES * \
+			sub_info->buffer_frames)) {
+		sub_info->boundary *= 2;
+	}
+	sub_info->dma_offset = 0;
+
+	return 0;
+}
+
+static int snd_ad73322_cap_pre(struct snd_pcm_substream *substream)
+{
+
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->rx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+
+	if (snd_BUG_ON(index < 0 || index > 7 || !sub_info))
+		return -EINVAL;
+	sub_info->period_frames = runtime->period_size;
+	sub_info->periods = runtime->periods;
+	sub_info->buffer_frames = runtime->buffer_size;
+	sub_info->frame_bytes = runtime->frame_bits / 8;
+	sub_info->dma_inter_pos = 0;
+	sub_info->dma_last_pos = 0;
+	sub_info->dma_pos_base = 0;
+	sub_info->next_inter_pos = sub_info->period_frames;
+	sub_info->data_count = 0;
+	sub_info->data_pos_base = 0;
+	sub_info->boundary = DMA_BUFFER_FRAMES * sub_info->buffer_frames;
+
+	while (sub_info->boundary * 2 <= (LONG_MAX - DMA_BUFFER_FRAMES * \
+			sub_info->buffer_frames)) {
+		sub_info->boundary *= 2;
+	}
+	sub_info->dma_offset = 0;
+	return 0;
+}
+
+
+
+static int snd_ad73322_play_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	substream_info_t *sub_info = (substream_info_t *)&(chip->tx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+
+	if (snd_BUG_ON(index < 0 || index > 7 || !sub_info))
+		return -EINVAL;
+
+	spin_lock(&chip->ad73322_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (!chip->tx_dma_started) {
+			chip->tx_dma_pos = 0;
+			bf53x_sport_tx_start(chip->sport);
+			if (!(chip->rx_status & RUN_TX_ALL))
+				snd_ad73322_startup(chip->card_index);
+			chip->tx_dma_started = 1;
+		}
+		sub_info->dma_offset = chip->tx_dma_pos;
+		chip->tx_status |= (1 << index);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		chip->tx_status &= ~ (1 << index);
+		if (!(chip->tx_status & RUN_TX_ALL)) {
+			chip->tx_dma_started = 0;
+			bf53x_sport_tx_stop(chip->sport);
+			if (!(chip->rx_status & RUN_TX_ALL))
+				snd_ad73322_stop(chip->card_index);
+		}
+		break;
+	default:
+		spin_unlock(&chip->ad73322_lock);
+		return -EINVAL;
+	}
+	spin_unlock(&chip->ad73322_lock);
+
+	snd_printd(KERN_INFO "cmd:%s\n", cmd ? "start" : "stop");
+	return 0;
+}
+
+static int snd_ad73322_cap_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	substream_info_t *sub_info = (substream_info_t *)&(chip->rx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+
+	if (snd_BUG_ON(index < 0 || index > 7 || !sub_info))
+		return -EINVAL;
+
+	spin_lock(&chip->ad73322_lock);
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		if (!chip->rx_dma_started) {
+			chip->rx_dma_pos = 0;
+			bf53x_sport_rx_start(chip->sport);
+			if (!(chip->tx_status & RUN_TX_ALL))
+				snd_ad73322_startup(chip->card_index);
+			chip->rx_dma_started = 1;
+		}
+		sub_info->dma_offset = chip->rx_dma_pos;
+		chip->rx_status |= (1 << index);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		chip->rx_status &= ~ (1 << index);
+		if (!(chip->rx_status & RUN_TX_ALL)) {
+			chip->rx_dma_started = 0;
+			bf53x_sport_rx_stop(chip->sport);
+			if (!(chip->tx_status & RUN_TX_ALL))
+				snd_ad73322_stop(chip->card_index);
+		}
+		break;
+	default:
+		spin_unlock(&chip->ad73322_lock);
+		return -EINVAL;
+	}
+	spin_unlock(&chip->ad73322_lock);
+
+	snd_printd(KERN_INFO "cmd:%s\n", cmd ? "start" : "stop");
+	return 0;
+}
+
+static snd_pcm_uframes_t snd_ad73322_play_ptr(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	substream_info_t *sub_info = (substream_info_t *)&(chip->tx_substreams[substream->pcm->device]);
+	unsigned long diff = bf53x_sport_curr_offset_tx(chip->sport);
+	unsigned long bytes_per_frame = 8*2;
+	size_t frames = diff / bytes_per_frame;
+	frames = (frames + DMA_BUFFER_FRAMES - sub_info->dma_offset) % \
+						DMA_BUFFER_FRAMES;
+
+	if (sub_info->dma_last_pos > frames) {
+		sub_info->dma_pos_base += DMA_BUFFER_FRAMES;
+		if (sub_info->dma_pos_base >= sub_info->boundary)
+			sub_info->dma_pos_base -= sub_info->boundary;
+	}
+	sub_info->dma_last_pos = frames;
+	frames = (frames + sub_info->dma_pos_base) % sub_info->buffer_frames;
+	return frames;
+}
+
+static snd_pcm_uframes_t snd_ad73322_cap_ptr(struct snd_pcm_substream *substream)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	substream_info_t *sub_info = (substream_info_t *)&(chip->rx_substreams[substream->pcm->device]);
+	unsigned long diff = bf53x_sport_curr_offset_rx(chip->sport);
+	unsigned long bytes_per_frame = 8*2;
+	size_t frames = diff / bytes_per_frame;
+	frames = (frames + DMA_BUFFER_FRAMES - sub_info->dma_offset) % \
+						DMA_BUFFER_FRAMES;
+
+	if (sub_info->dma_last_pos > frames) {
+		sub_info->dma_pos_base += DMA_BUFFER_FRAMES;
+		if (sub_info->dma_pos_base >= sub_info->boundary)
+			sub_info->dma_pos_base -= sub_info->boundary;
+	}
+	sub_info->dma_last_pos = frames;
+	frames = (frames + sub_info->dma_pos_base) % sub_info->buffer_frames;
+	return frames;
+}
+
+static int snd_ad73322_play_copy(struct snd_pcm_substream *substream, int channel,
+		snd_pcm_uframes_t pos, void *src, snd_pcm_uframes_t count)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	unsigned short *isrc = (unsigned short *)src;
+	unsigned short *dst = (unsigned short *)chip->tx_dma_buf;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->tx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+	snd_pcm_uframes_t start, temp_count, temp2_count;
+	int slot_index = NUM_DEVICES_CHAIN-(index + 1);
+
+	start = (sub_info->data_pos_base + pos + sub_info->dma_offset) % \
+							DMA_BUFFER_FRAMES;
+	if (start + count > DMA_BUFFER_FRAMES) {
+		temp_count = DMA_BUFFER_FRAMES - start;
+		temp2_count = start + count - DMA_BUFFER_FRAMES;
+	} else {
+		temp_count = count;
+		temp2_count = 0;
+	}
+	dst += start * 8;
+	while (temp_count--) {
+		*(dst + slot_index) = *isrc++;
+		dst += 8;
+	}
+
+	if (temp2_count) {
+		dst = (unsigned short *)chip->tx_dma_buf;
+		while (temp2_count--) {
+			*(dst + slot_index) = *isrc++;
+			dst += 8;
+		}
+	}
+	sub_info->data_count += count;
+	if (sub_info->data_count >= sub_info->buffer_frames) {
+		sub_info->data_count -= sub_info->buffer_frames;
+		sub_info->data_pos_base += sub_info->buffer_frames;
+		if (sub_info->data_pos_base >= sub_info->boundary)
+			sub_info->data_pos_base -= sub_info->boundary;
+	}
+	return 0;
+}
+
+static int snd_ad73322_cap_copy(struct snd_pcm_substream *substream, int channel,
+		snd_pcm_uframes_t pos, void *dst, snd_pcm_uframes_t count)
+{
+	ad73322_t *chip = snd_pcm_substream_chip(substream);
+	unsigned short *idst = (unsigned short *)dst;
+	unsigned short *src = (unsigned short *)chip->rx_dma_buf;
+	substream_info_t *sub_info = (substream_info_t *)&(chip->rx_substreams[substream->pcm->device]);
+	int index = substream->pcm->device;
+	snd_pcm_uframes_t start, temp_count, temp2_count;
+	int slot_index = get_cap_slotindex(index);
+
+	start = (sub_info->data_pos_base + pos + sub_info->dma_offset) % \
+							DMA_BUFFER_FRAMES;
+	if (start + count > DMA_BUFFER_FRAMES) {
+		temp_count = DMA_BUFFER_FRAMES - start;
+		temp2_count = start + count - DMA_BUFFER_FRAMES;
+	} else {
+		temp_count = count;
+		temp2_count = 0;
+	}
+	src += start * 8;
+	while (temp_count--) {
+		*idst++ = *(src + slot_index);
+		src += 8;
+	}
+
+	if (temp2_count) {
+		src = (unsigned short *)chip->rx_dma_buf;
+		while (temp2_count--) {
+			*idst++ = *(src + slot_index);
+			src += 8;
+		}
+	}
+	sub_info->data_count += count;
+	if (sub_info->data_count >= sub_info->buffer_frames) {
+		sub_info->data_count -= sub_info->buffer_frames;
+		sub_info->data_pos_base += sub_info->buffer_frames;
+		if (sub_info->data_pos_base >= sub_info->boundary)
+			sub_info->data_pos_base -= sub_info->boundary;
+	}
+	return 0;
+}
+
+/* pcm method tables */
+
+static struct snd_pcm_ops snd_ad73322_play_ops = {
+	.open      = snd_ad73322_play_open,
+	.close     = snd_ad73322_play_close,
+	.ioctl     = snd_pcm_lib_ioctl,
+	.hw_params = snd_ad73322_hw_params,
+	.hw_free   = snd_ad73322_hw_free,
+	.prepare   = snd_ad73322_play_pre,
+	.trigger   = snd_ad73322_play_trigger,
+	.pointer   = snd_ad73322_play_ptr,
+	.copy	   = snd_ad73322_play_copy,
+};
+
+
+static struct snd_pcm_ops snd_ad73322_cap_ops = {
+	.open  = snd_ad73322_cap_open,
+	.close = snd_ad73322_cap_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = snd_ad73322_hw_params,
+	.hw_free   = snd_ad73322_hw_free,
+	.prepare   = snd_ad73322_cap_pre,
+	.trigger   = snd_ad73322_cap_trigger,
+	.pointer   = snd_ad73322_cap_ptr,
+	.copy	   = snd_ad73322_cap_copy,
+};
+
+static inline void snd_ad73322_update(substream_info_t *sub_info)
+{
+	sub_info->dma_inter_pos += DMA_PERIOD_FRAMES;
+	if (sub_info->dma_inter_pos >= sub_info->boundary)
+		sub_info->dma_inter_pos -= sub_info->boundary;
+
+	if (sub_info->dma_inter_pos >= sub_info->next_inter_pos) {
+		snd_pcm_period_elapsed(sub_info->substream);
+		sub_info->next_inter_pos += sub_info->period_frames;
+		if (sub_info->next_inter_pos >= sub_info->boundary)
+			sub_info->next_inter_pos -= sub_info->boundary;
+	}
+}
+
+
+static void snd_ad73322_dma_rx(void *data)
+{
+	struct snd_ad73322 *ad73322 = data;
+	int index;
+	substream_info_t *sub_info = NULL;
+	ad73322->rx_dma_pos = (ad73322->rx_dma_pos + DMA_PERIOD_FRAMES) % \
+						DMA_BUFFER_FRAMES;
+	for (index = 0; index < 8; index++) {
+		sub_info = &ad73322->rx_substreams[index];
+		if (sub_info->substream && ad73322->rx_status & (1<<index)) {
+			snd_ad73322_update(sub_info);
+		}
+	}
+}
+
+static void snd_ad73322_dma_tx(void *data)
+{
+	struct snd_ad73322 *ad73322 = data;
+	int index;
+	substream_info_t *sub_info = NULL;
+	ad73322->tx_dma_pos = (ad73322->tx_dma_pos + DMA_PERIOD_FRAMES) % \
+						DMA_BUFFER_FRAMES;
+	for (index = 0; index < 8; index++) {
+		sub_info = &ad73322->tx_substreams[index];
+		if (sub_info->substream && ad73322->tx_status & (1<<index)) {
+			snd_ad73322_update(sub_info);
+		}
+	}
+}
+
+static void snd_ad73322_sport_err(void *data)
+{
+	printk(KERN_ERR "%s: error happened on sport\n", __FUNCTION__);
+}
+
+/*************************************************************
+ *      card and device
+ *************************************************************/
+static void snd_ad73322_startup(int index)
+{
+	snd_printd(KERN_INFO "%s is called\n", __FUNCTION__);
+	if (index == 0)
+		gpio_direction_output(GPIO_SPORT0_SE, 1);
+	else
+		gpio_direction_output(GPIO_SPORT1_SE, 1);
+}
+
+static void snd_ad73322_stop(int index)
+{
+	snd_printd(KERN_INFO "%s is called\n", __FUNCTION__);
+	/* Pull down SE pin on AD73322 */
+	if (index == 0)
+		gpio_direction_output(GPIO_SPORT0_SE, 0);
+	else
+		gpio_direction_output(GPIO_SPORT1_SE, 0);
+}
+
+static void snd_ad73322_reset(void)
+{
+	snd_printd(KERN_INFO "%s is called\n", __FUNCTION__);
+
+	/* Pull down GPIO_RESET pin on AD73322 */
+	gpio_direction_output(GPIO_RESET, 0);
+	udelay(200);
+	gpio_direction_output(GPIO_RESET, 1);
+
+}
+
+/*************************************************************
+ *                 ALSA Card Level
+ *************************************************************/
+static int snd_ad73322_configure(int index)
+{
+	short ctrl_regs[8];
+	short dev_addr,reg_addr;
+	int i, j;
+	unsigned short status = 0;
+	short ctrl_buffer[NUM_DEVICES_CHAIN*8];
+	short *pctrl_buffer;
+
+	/*regs configuration */
+	ctrl_regs[7] = (NUM_DEVICES_CHAIN-1)<<4 | MODE_DATA;
+	ctrl_regs[0] = MCDIV(0) | SCDIV(0) | DIRATE(0);
+	ctrl_regs[1] = PUDEV | PUADC | PUDAC | PUREF | REFUSE ;
+	ctrl_regs[2] = 0;
+	ctrl_regs[3] = DA(0);
+	ctrl_regs[4] = SEEN;
+	ctrl_regs[5] = 0;
+	ctrl_regs[6] = 0;
+
+	pctrl_buffer = &ctrl_buffer[0];
+	reg_addr = 1;
+	for (i = 0; i < 8; i++)
+	{
+		dev_addr = NUM_DEVICES_CHAIN - 1;
+		for (j=0; j<NUM_DEVICES_CHAIN; j++)
+		{
+			*pctrl_buffer++ = ctrl_regs[i] | (dev_addr<<11) | (reg_addr<<8) | AD_CONTROL;
+			dev_addr--;
+		}
+	reg_addr++;
+	if(reg_addr == 8) reg_addr = 0;
+
+	}
+	snd_ad73322_reset();
+	local_irq_disable();
+	udelay(1);
+#ifdef HAVE_TWO_CARDS
+	bfin_write_SPORT0_TCR1(TFSR);
+	bfin_write_SPORT0_TCR2(0xF);
+	SSYNC();
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < NUM_DEVICES_CHAIN; j++)
+			bfin_write_SPORT0_TX16(ctrl_buffer[8*i+j]);
+		bfin_write_SPORT0_TCR1(bfin_read_SPORT0_TCR1() | TSPEN);
+		SSYNC();
+		status = bfin_read_SPORT0_STAT();
+		while (!(status & TUVF)) {
+			udelay(1);
+			status = bfin_read_SPORT0_STAT();
+			SSYNC();
+		}
+		bfin_write_SPORT0_TCR1(bfin_read_SPORT0_TCR1() & ~TSPEN);
+		SSYNC();
+	}
+	SSYNC();
+	snd_ad73322_stop(0);
+	bfin_write_SPORT1_TCR1(TFSR);
+	bfin_write_SPORT1_TCR2(0xF);
+	SSYNC();
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < NUM_DEVICES_CHAIN; j++)
+			bfin_write_SPORT1_TX16(ctrl_buffer[8*i+j]);
+		bfin_write_SPORT1_TCR1(bfin_read_SPORT1_TCR1() | TSPEN);
+		SSYNC();
+		status = bfin_read_SPORT1_STAT();
+		while (!(status & TUVF)) {
+			udelay(1);
+			status = bfin_read_SPORT1_STAT();
+			SSYNC();
+		}
+		bfin_write_SPORT1_TCR1(bfin_read_SPORT1_TCR1() & ~TSPEN);
+		SSYNC();
+	}
+	SSYNC();
+	snd_ad73322_stop(1);
+#else
+	bfin_write_SPORT_TCR1(TFSR);
+	bfin_write_SPORT_TCR2(0xF);
+	SSYNC();
+
+	for (i = 0; i < 8; i++) {
+		for (j=0; j<NUM_DEVICES_CHAIN; j++)
+			bfin_write_SPORT_TX16(ctrl_buffer[8*i+j]);
+		bfin_write_SPORT_TCR1(bfin_read_SPORT_TCR1() | TSPEN);
+		status = bfin_read_SPORT_STAT();
+		while (!(status & TUVF)){
+			udelay(1);
+			status = bfin_read_SPORT_STAT();
+			SSYNC();
+		}
+		bfin_write_SPORT_TCR1(bfin_read_SPORT_TCR1() & ~TSPEN);
+	}
+	SSYNC();
+	snd_ad73322_stop(index);
+#endif
+	local_irq_enable();
+
+
+	return 0;
+}
+
+static int __devinit snd_ad73322_pcm(struct snd_ad73322 *ad73322, int dev)
+{
+	int err = 0;
+	struct snd_pcm *pcm;
+
+	/* 1 playback and 1 capture substream */
+	if ((err = snd_pcm_new(ad73322->card, pcm_name[dev], dev, 1, 1, &pcm))) {
+		return err;
+	}
+
+	ad73322->pcm[dev] = pcm;
+	strcpy(pcm->name, pcm_name[dev]);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,
+			&snd_ad73322_play_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
+			&snd_ad73322_cap_ops);
+	pcm->private_data = ad73322;
+	pcm->info_flags = 0;
+	return 0;
+}
+
+static int __devinit snd_ad73322_probe(struct platform_device *pdev)
+{
+	int err;
+	struct snd_card *card = NULL;
+	struct snd_ad73322 *ad73322 = NULL;
+	struct bf53x_sport *sport = NULL;
+	int i;
+	dma_addr_t addr;
+#if CONFIG_SND_BFIN_SPORT != 0
+	unsigned short tmp_reg;
+#endif
+	if (pdev->id == 0) {
+#if CONFIG_SND_BFIN_SPORT == 0
+		if (gpio_request(GPIO_SPORT0_SE, "AD73322")) {
+			printk(KERN_ERR "%s: Failed ro request GPIO_%d\n", __FUNCTION__, GPIO_SPORT0_SE);
+			return -EBUSY;
+		}
+		gpio_direction_output(GPIO_SPORT0_SE, 1);
+#elif CONFIG_SND_BFIN_SPORT == 1
+		if (gpio_request(GPIO_SPORT1_SE, "AD73322")) {
+			printk(KERN_ERR "%s: Failed ro request GPIO_%d\n", __FUNCTION__, GPIO_SPORT1_SE);
+			return -EBUSY;
+		}
+		gpio_direction_output(GPIO_SPORT1_SE, 1);
+#elif CONFIG_SND_BFIN_SPORT == 2
+		if (gpio_request(GPIO_SPORT0_SE, "AD73322")) {
+			printk(KERN_ERR "%s: Failed ro request GPIO_%d\n", __FUNCTION__, GPIO_SPORT0_SE);
+			return -EBUSY;
+		}
+		if (gpio_request(GPIO_SPORT1_SE, "AD73322")) {
+			printk(KERN_ERR "%s: Failed ro request GPIO_%d\n", __FUNCTION__, GPIO_SPORT1_SE);
+			return -EBUSY;
+		}
+		gpio_direction_output(GPIO_SPORT0_SE, 1);
+		gpio_direction_output(GPIO_SPORT1_SE, 1);
+#endif
+		if (gpio_request(GPIO_RESET, "AD73322RST")) {
+			printk(KERN_ERR "%s: Failed ro request GPIO_12\n", __FUNCTION__);
+			return -EBUSY;
+		}
+		gpio_direction_output(GPIO_RESET, 0);
+#if CONFIG_SND_BFIN_SPORT != 0
+		tmp_reg = bfin_read_PORT_MUX();
+		bfin_write_PORT_MUX(tmp_reg|0x0E00);
+		bfin_write_PORTG_FER(0xFFFF);
+#endif
+	}
+
+	snd_card_create(-1, NULL, THIS_MODULE, sizeof(struct snd_ad73322), &card);
+	if (card == NULL)
+		return -ENOMEM;
+	ad73322 = card->private_data;
+	ad73322->card = card;
+#ifdef HAVE_TWO_CARDS
+	ad73322->card_index = pdev->id;
+#else
+#if CONFIG_SND_BFIN_SPORT == 0
+	ad73322->card_index = 0;
+#elif CONFIG_SND_BFIN_SPORT == 1
+	ad73322->card_index = 1;
+#endif
+#endif
+	/*Only need to initialize CODECS once*/
+	if (pdev->id == 0) {
+		if ((err = snd_ad73322_configure(ad73322->card_index)) < 0)
+			return -EFAULT;
+	}
+	ad73322->tx_dma_buf = dma_alloc_coherent(NULL, AD73322_BUF_SZ, &addr, GFP_KERNEL);
+	if (!ad73322->tx_dma_buf) {
+		printk(KERN_ERR "Failed to allocate dma memory\n");
+		return -ENOMEM;
+	}
+	ad73322->rx_dma_buf = dma_alloc_coherent(NULL, AD73322_BUF_SZ, &addr, GFP_KERNEL);
+	if (!ad73322->rx_dma_buf) {
+		dma_free_coherent(NULL, AD73322_BUF_SZ, ad73322->tx_dma_buf, 0);
+		printk(KERN_ERR "Failed to allocate dma memory\n");
+		return -ENOMEM;
+	}
+#ifdef HAVE_TWO_CARDS
+	if (pdev->id == 0) {
+		sport = bf53x_sport_init(0,
+			CH_SPORT0_RX, snd_ad73322_dma_rx,
+			CH_SPORT0_TX, snd_ad73322_dma_tx,
+			IRQ_SPORT0_ERROR, snd_ad73322_sport_err, 2, ad73322);
+		if (sport == NULL) {
+			err = -ENODEV;
+			goto __sport_err;
+		}
+	} else if (pdev->id == 1) {
+		sport = bf53x_sport_init(1,
+			CH_SPORT1_RX, snd_ad73322_dma_rx,
+			CH_SPORT1_TX, snd_ad73322_dma_tx,
+			IRQ_SPORT1_ERROR, snd_ad73322_sport_err, 2, ad73322);
+		if (sport == NULL) {
+			err = -ENODEV;
+			goto __sport_err;
+		}
+	}
+#else
+	sport = bf53x_sport_init(CONFIG_SND_BFIN_SPORT,
+		SPORT_DMA_RX, snd_ad73322_dma_rx,
+		SPORT_DMA_TX, snd_ad73322_dma_tx,
+		SPORT_IRQ_ERR, snd_ad73322_sport_err, 2, ad73322);
+	if (sport == NULL) {
+		err = -ENODEV;
+		goto __sport_err;
+	}
+#endif
+	ad73322->sport = sport;
+	for (i = 0; i < NUM_DEVICES_CHAIN; i++) {
+		if ((err = snd_ad73322_pcm(ad73322, i)) < 0)
+			goto __nodev;
+	}
+	bf53x_sport_config_rx(sport, RFSR, 0xF, 0, 0);
+	bf53x_sport_config_tx(sport, TFSR, 0xF, 0, 0);
+	bf53x_sport_set_multichannel(sport, 1, 1);
+	bf53x_sport_config_rx_dma(sport, ad73322->rx_dma_buf,
+			DMA_PERIODS, DMA_PERIOD_BYTES, 2);
+	bf53x_sport_config_tx_dma(sport, ad73322->tx_dma_buf,
+			DMA_PERIODS, DMA_PERIOD_BYTES, 2);
+	strcpy(card->driver, DRIVER_NAME);
+	strcpy(card->shortname, CHIP_NAME);
+#ifdef HAVE_TWO_CARDS
+	if (pdev->id == 0) {
+		sprintf(card->longname, "%s at PF%d SPORT%d,rx/tx dma ch:%d/%d,err irq:%d",
+			card->shortname,
+			GPIO_SPORT0_SE,
+			0,
+			CH_SPORT0_RX, CH_SPORT0_TX, IRQ_SPORT0_ERROR);
+	} else if (pdev->id == 1) {
+		sprintf(card->longname, "%s at PF%d SPORT%d,rx/tx dma ch:%d/%d,err irq:%d",
+			card->shortname,
+			GPIO_SPORT1_SE,
+			1,
+			CH_SPORT1_RX, CH_SPORT1_TX, IRQ_SPORT1_ERROR);
+	}
+#else
+	sprintf(card->longname, "%s at PF%d SPORT%d,rx/tx dma ch:%d/%d,err irq:%d",
+	        card->shortname,
+	        CONFIG_SND_BFIN_AD73322_SE,
+	        CONFIG_SND_BFIN_SPORT,
+	        SPORT_DMA_RX, SPORT_DMA_TX, SPORT_IRQ_ERR);
+#endif
+	snd_card_set_dev(card, (&pdev->dev));
+	if ((err = snd_card_register(card)) < 0) {
+		goto __nodev;
+	}
+
+	platform_set_drvdata(pdev, card);
+
+	return 0;
+
+__nodev:
+	bf53x_sport_done(sport);
+__sport_err:
+	dma_free_coherent(NULL, AD73322_BUF_SZ, ad73322->tx_dma_buf, 0);
+	dma_free_coherent(NULL, AD73322_BUF_SZ, ad73322->rx_dma_buf, 0);
+	snd_card_free(card);
+	return err;
+}
+
+static int __devexit snd_ad73322_remove(struct platform_device *pdev)
+{
+	struct snd_card *card;
+	struct snd_ad73322 *ad73322;
+
+	card = platform_get_drvdata(pdev);
+	ad73322 = card->private_data;
+	dma_free_coherent(NULL, AD73322_BUF_SZ, ad73322->tx_dma_buf, 0);
+	dma_free_coherent(NULL, AD73322_BUF_SZ, ad73322->rx_dma_buf, 0);
+	snd_ad73322_stop(ad73322->card_index);
+	bf53x_sport_done(ad73322->sport);
+	/*only release it once*/
+	if (pdev->id == 0)
+		gpio_free(GPIO_RESET);
+	if (ad73322->card_index == 0)
+		gpio_free(GPIO_SPORT0_SE);
+	else
+		gpio_free(GPIO_SPORT1_SE);
+	snd_card_free(card);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int snd_ad73322_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_ad73322 *ad73322 = card->private_data;
+	int i;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3hot);
+	for (i = 0; i < NUM_DEVICES_CHAIN; i++)
+		snd_pcm_suspend_all(ad73322->pcm[i]);
+
+	return 0;
+}
+static int snd_ad73322_resume(struct platform_device *pdev)
+{
+	int err = 0;
+	struct snd_card *card = platform_get_drvdata(pdev);
+	struct snd_ad73322 *ad73322 = card->private_data;
+	err = bf53x_sport_config_rx(ad73322->sport, RFSR, 0xF, 0, 0);
+	err = err || bf53x_sport_config_tx(ad73322->sport, TFSR, 0xF, 0, 0);
+	if (err)
+		snd_printk(KERN_ERR "Unable to set sport configuration\n");
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
+
+	return 0;
+}
+#endif
+
+static struct platform_driver snd_ad73322_driver = {
+	.probe		= snd_ad73322_probe,
+	.remove		= __devexit_p(snd_ad73322_remove),
+#ifdef CONFIG_PM
+	.suspend	= snd_ad73322_suspend,
+	.resume		= snd_ad73322_resume,
+#endif
+	.driver		= {
+			.name = DRIVER_NAME,
+	},
+};
+
+static int __init snd_ad73322_init(void)
+{
+	int err, i;
+
+	if (input_gain > 7) {
+		printk(KERN_NOTICE DRIVER_NAME ": valid input_gain values are 0 to 7 inclusive\n");
+		return -EINVAL;
+	}
+
+	if (output_gain > 7) {
+		printk(KERN_NOTICE DRIVER_NAME ": valid output_gain values are 0 to 7 inclusive\n");
+		return -EINVAL;
+	}
+
+	if ((err = platform_driver_register(&snd_ad73322_driver))<0)
+		return err;
+
+	for (i = 0; i < CARD_NUM; i++) {
+		device[i] = platform_device_register_simple(DRIVER_NAME, i, NULL, 0);
+		if (IS_ERR(device[i])) {
+			err = PTR_ERR(device[i]);
+			platform_driver_unregister(&snd_ad73322_driver);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static void __exit snd_ad73322_exit(void)
+{
+	int i;
+
+	for (i = 0; i < CARD_NUM; i++)
+		platform_device_unregister(device[i]);
+	platform_driver_unregister(&snd_ad73322_driver);
+}
+
+MODULE_AUTHOR("Cliff Cai <Cliff.Cai@analog.com>");
+MODULE_DESCRIPTION("Blackfin/ADI AD73322");
+MODULE_LICENSE("GPL");
+
+module_init(snd_ad73322_init);
+module_exit(snd_ad73322_exit);
diff --git a/sound/blackfin/ad73322.h b/sound/blackfin/ad73322.h
new file mode 100644
index 0000000..4961a98
--- /dev/null
+++ b/sound/blackfin/ad73322.h
@@ -0,0 +1,135 @@
+/*
+ * File:         sound/blackfin/ad73322.c
+ * Based on:	 sound/blackfin/ad73311.c
+ * Author:       Cliff Cai <Cliff.Cai@analog.com>
+ *
+ * Created:      Tue May 06 2008
+ * Description:  Driver for AD73322 sound chip connected to bf53x sport
+ *
+ * Rev:          $Id: ad73322.c 4104 2008-05-06 06:51:48Z cliff $
+ *
+ * Modified:
+ *               Copyright 2008 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __AD73322_H__
+#define __AD73322_H__
+
+/*8 means 4 AD73322 is connected in cascade mode,since every AD73322 has 2
+ *DAC/ADC pairs
+ */
+#define NUM_DEVICES_CHAIN 8
+
+#define RUN_TX_ALL 0xff
+#define RUN_RX_ALL 0xff
+
+#define AD_CONTROL	0x8000
+#define AD_DATA		0x0000
+#define AD_READ		0x4000
+#define AD_WRITE	0x0000
+
+/* Control register A */
+#define CTRL_REG_A	(0 << 8)
+
+#define MODE_PRO	0x00
+#define MODE_DATA	0x01
+#define MODE_MIXED	0x03
+#define DLB		0x04
+#define SLB		0x08
+#define DEVC(x)		((x & 0x7) << 4)
+#define RESET		0x80
+
+/* Control register B */
+#define CTRL_REG_B	(1 << 8)
+
+#define DIRATE(x)	(x & 0x3)
+#define SCDIV(x)	((x & 0x3) << 2)
+#define MCDIV(x)	((x & 0x7) << 4)
+#define CEE		(1 << 7)
+
+/* Control register C */
+#define CTRL_REG_C	(2 << 8)
+
+#define PUDEV		( 1 << 0 )
+#define PUADC		( 1 << 3 )
+#define PUDAC		( 1 << 4 )
+#define PUREF		( 1 << 5 )
+#define REFUSE		( 1 << 6 )
+
+/* Control register D */
+#define CTRL_REG_D	(3 << 8)
+
+#define IGS(x)		(x & 0x7)
+#define RMOD		( 1 << 3 )
+#define OGS(x)		((x & 0x7) << 4)
+#define MUTE		(1 << 7)
+
+/* Control register E */
+#define CTRL_REG_E	(4 << 8)
+
+#define DA(x)		(x & 0x1f)
+#define IBYP		( 1 << 5 )
+
+/* Control register F */
+#define CTRL_REG_F	(5 << 8)
+
+#define SEEN		( 1 << 5 )
+#define INV		( 1 << 6 )
+#define ALB		( 1 << 7 )
+
+
+typedef struct {
+	struct snd_pcm_substream*	substream;
+	snd_pcm_uframes_t	dma_offset;
+	snd_pcm_uframes_t	buffer_frames;
+	snd_pcm_uframes_t	period_frames;
+	unsigned int		periods;
+	unsigned int		frame_bytes;
+	/* Information about DMA */
+	snd_pcm_uframes_t	dma_inter_pos;
+	snd_pcm_uframes_t	dma_last_pos;
+	snd_pcm_uframes_t	dma_pos_base;
+	/* Information on virtual buffer */
+	snd_pcm_uframes_t	next_inter_pos;
+	snd_pcm_uframes_t	data_count;
+	snd_pcm_uframes_t	data_pos_base;
+	snd_pcm_uframes_t	boundary;
+} substream_info_t;
+
+typedef struct snd_ad73322 {
+	struct snd_card	*card;
+	struct bf53x_sport	*sport;
+	spinlock_t    ad73322_lock;
+	struct snd_pcm	*pcm[NUM_DEVICES_CHAIN];
+	int	tx_dma_started;
+	int	tx_status;
+	int	rx_dma_started;
+	int	rx_status;
+
+	snd_pcm_uframes_t	tx_dma_pos;
+	snd_pcm_uframes_t	rx_dma_pos;
+	substream_info_t	tx_substreams[8];
+	substream_info_t	rx_substreams[8];
+	unsigned char *tx_dma_buf;
+	unsigned char *rx_dma_buf;
+	int card_index;
+} ad73322_t;
+
+#endif
diff --git a/sound/blackfin/bf53x_sport.c b/sound/blackfin/bf53x_sport.c
new file mode 100644
index 0000000..87a06cf
--- /dev/null
+++ b/sound/blackfin/bf53x_sport.c
@@ -0,0 +1,916 @@
+/*
+ * File:         sound/blackfin/bf53x_sport.c
+ * Based on:
+ * Author:       Luuk van Dijk <blackfin@mdnmttr.nl>
+ *
+ * Created:      Tue Sep 21 10:52:42 CEST 2004
+ * Description:  low level driver for sportX/dmaY on blackfin 53x
+ *               this should be moved to arch/blackfin/
+ *
+ *               Copyright 2004-2006 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+
+/*
+ * notes:
+ *
+ *  - apparently you can't read back dma->start_addr, as it will stall
+ *  the DMA (at least for tx)!  (learnt the hard way...)
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <asm/bug.h>
+#include <asm/dma.h>
+#include <linux/dma-mapping.h>
+
+#include "bf53x_sport.h"
+
+//#define BF53X_SPORT_DEBUG
+
+#ifdef  BF53X_SPORT_DEBUG
+#define sport_printd(level, format, arg...) \
+		printk(level "sport: " format, ## arg)
+#define SPORT_ASSERT(expr) \
+	do { \
+		if (unlikely(!(expr))) { \
+			printk(KERN_ERR "%s: %d, bug\n", __FUNCTION__, __LINE__); \
+		} \
+	} while(0)
+#else
+#define sport_printd(level, format, arg...)
+#define SPORT_ASSERT(expr)
+#endif
+
+#include <asm/blackfin.h>
+#include <asm/dma.h>
+#include <asm/cacheflush.h>
+#include <asm/portmux.h>
+
+/* delay between frame sync pulse and first data bit in multichannel mode */
+#define FRAME_DELAY (1<<12)
+
+#define DRV_NAME "bf53x_sport"
+
+unsigned short bfin_snd_pin_req_sport0[] =
+	{P_SPORT0_TFS, P_SPORT0_DTPRI, P_SPORT0_TSCLK, P_SPORT0_RFS, \
+	 P_SPORT0_DRPRI, P_SPORT0_RSCLK, 0};
+
+unsigned short bfin_snd_pin_req_sport1[] =
+	{P_SPORT1_TFS, P_SPORT1_DTPRI, P_SPORT1_TSCLK, P_SPORT1_RFS, \
+	P_SPORT1_DRPRI, P_SPORT1_RSCLK, 0};
+
+static unsigned int sport_iobase[] = {SPORT0_TCR1, SPORT1_TCR1 };
+
+/* note: multichannel is in units of 8 channels,
+ * tdm_count is # channels NOT / 8 ! */
+int bf53x_sport_set_multichannel(struct bf53x_sport *sport,
+		int tdm_count, int packed)
+{
+	sport_printd(KERN_INFO, "%s( tdm_count=%d packed=%d )\n",
+				__FUNCTION__, tdm_count, packed);
+
+	if ((sport->regs->tcr1 & TSPEN) || (sport->regs->rcr1 & RSPEN))
+		return -EBUSY;
+
+	if (tdm_count & 0x7)
+		return -EINVAL;
+
+	if (tdm_count > 32)
+		return -EINVAL;  /* don't feel like overdoing it today :-) */
+
+	SSYNC(); /* is this really neccesary? */
+
+	if (tdm_count) {
+		int shift = 32 - tdm_count;
+		unsigned int mask = (0xffffffff >> shift);
+
+		sport->regs->mcmc1 = ((tdm_count>>3)-1) << 12;
+		sport->regs->mcmc2 = FRAME_DELAY| MCMEN | \
+				(packed ? (MCDTXPE|MCDRXPE) : 0);
+
+		sport->regs->mtcs0 = mask;
+		sport->regs->mrcs0 = mask;
+	} else {
+		sport->regs->mcmc1 = 0;
+		sport->regs->mcmc2 = 0;
+
+		sport->regs->mtcs0 = 0;
+		sport->regs->mrcs0 = 0;
+	}
+
+	sport->regs->mtcs1 = 0; sport->regs->mtcs2 = 0; sport->regs->mtcs3 = 0;
+	sport->regs->mrcs1 = 0; sport->regs->mrcs2 = 0; sport->regs->mrcs3 = 0;
+
+	SSYNC();
+
+	return 0;
+}
+
+int bf53x_sport_config_rx(struct bf53x_sport *sport, unsigned int rcr1,
+		unsigned int rcr2, unsigned int clkdiv, unsigned int fsdiv)
+{
+	if ((sport->regs->tcr1 & TSPEN) || (sport->regs->rcr1 & RSPEN))
+		return -EBUSY;
+
+	sport->regs->rcr1 = rcr1;
+	sport->regs->rcr2 = rcr2;
+	sport->regs->rclkdiv = clkdiv;
+	sport->regs->rfsdiv = fsdiv;
+
+	SSYNC();
+
+	return 0;
+}
+
+int bf53x_sport_config_tx(struct bf53x_sport *sport, unsigned int tcr1,
+		unsigned int tcr2, unsigned int clkdiv, unsigned int fsdiv)
+{
+	if ((sport->regs->tcr1 & TSPEN) || (sport->regs->rcr1 & RSPEN))
+		return -EBUSY;
+
+	sport->regs->tcr1 = tcr1;
+	sport->regs->tcr2 = tcr2;
+	sport->regs->tclkdiv = clkdiv;
+	sport->regs->tfsdiv = fsdiv;
+
+	SSYNC();
+
+	return 0;
+}
+
+static void setup_desc(struct dmasg *desc, void *buf, int fragcount,
+		size_t fragsize, unsigned int cfg,
+		unsigned int x_count, unsigned int ycount, size_t size)
+{
+
+	int i;
+
+	for (i=0; i<fragcount; ++i) {
+		desc[i].next_desc_addr  = &desc[i + 1];
+		desc[i].start_addr = (unsigned long)buf + i*fragsize;
+		desc[i].cfg = cfg;
+		desc[i].x_count = x_count;
+		desc[i].x_modify = size;
+		desc[i].y_count = ycount;
+		desc[i].y_modify = size;
+	}
+
+	/* make circular */
+	desc[fragcount-1].next_desc_addr = desc;
+
+	/* printk(KERN_ERR "setup desc: desc0=%p, next0=%lx, desc1=%p,"
+		"next1=%lx\nx_count=%x,y_count=%x,addr=0x%lx,cfs=0x%x\n",
+		&(desc[0]), desc[0].next_desc_addr,
+		&(desc[1]), desc[1].next_desc_addr,
+		desc[0].x_count, desc[0].y_count,
+		desc[0].start_addr,desc[0].cfg);
+	*/
+}
+
+static int sport_start(struct bf53x_sport *sport)
+{
+	enable_dma(sport->dma_rx_chan);
+	enable_dma(sport->dma_tx_chan);
+	sport->regs->tcr1 |= TSPEN;
+	sport->regs->rcr1 |= RSPEN;
+	SSYNC();
+
+	return 0;
+}
+
+static int sport_stop(struct bf53x_sport *sport)
+{
+	sport->regs->tcr1 &= ~TSPEN;
+	sport->regs->rcr1 &= ~RSPEN;
+	SSYNC();
+
+	disable_dma(sport->dma_rx_chan);
+	disable_dma(sport->dma_tx_chan);
+
+	return 0;
+}
+
+static inline int sport_hook_rx_dummy(struct bf53x_sport *sport)
+{
+	struct dmasg *desc, temp_desc;
+	unsigned long flags;
+
+	SPORT_ASSERT(sport->dummy_rx_desc != NULL);
+	SPORT_ASSERT(sport->curr_rx_desc != sport->dummy_rx_desc);
+
+	sport->dummy_rx_desc->next_desc_addr = sport->dummy_rx_desc + 1;
+
+	local_irq_save(flags);
+	desc = (struct dmasg *)get_dma_next_desc_ptr(sport->dma_rx_chan);
+	/* Copy the descriptor which will be damaged to backup */
+	temp_desc = *desc;
+	desc->x_count=0x10;
+	desc->y_count=0;
+	desc->next_desc_addr = sport->dummy_rx_desc;
+	local_irq_restore(flags);
+	/* Waiting for dummy buffer descriptor is already hooked*/
+	while ((get_dma_curr_desc_ptr(sport->dma_rx_chan) - \
+	        sizeof(struct dmasg)) != sport->dummy_rx_desc)
+		continue;
+	sport->curr_rx_desc = sport->dummy_rx_desc;
+	/* Restore the damaged descriptor */
+	*desc = temp_desc;
+
+	return 0;
+}
+
+static inline int sport_rx_dma_start(struct bf53x_sport *sport, int dummy)
+{
+	struct dma_register *dma = sport->dma_rx;
+
+	if (dummy) {
+		sport->dummy_rx_desc->next_desc_addr = sport->dummy_rx_desc;
+		sport->curr_rx_desc = sport->dummy_rx_desc;
+	} else
+		sport->curr_rx_desc = sport->dma_rx_desc;
+
+	dma->next_desc_ptr = sport->curr_rx_desc;
+	dma->cfg           = DMAFLOW_LARGE | NDSIZE_9 | WDSIZE_32 | WNR;
+	dma->x_count       = 0;
+	dma->x_modify      = 0;
+	dma->y_count       = 0;
+	dma->y_modify      = 0;
+
+	SSYNC();
+
+	return 0;
+}
+
+static inline int sport_tx_dma_start(struct bf53x_sport *sport, int dummy)
+{
+	struct dma_register *dma = sport->dma_tx;
+
+	if (dummy) {
+		sport->dummy_tx_desc->next_desc_addr = sport->dummy_tx_desc;
+		sport->curr_tx_desc = sport->dummy_tx_desc;
+	} else
+		sport->curr_tx_desc = sport->dma_tx_desc;
+
+	dma->next_desc_ptr = sport->curr_tx_desc;
+	dma->cfg           = DMAFLOW_LARGE | NDSIZE_9 | WDSIZE_32 ;
+	dma->x_count       = 0;
+	dma->x_modify      = 0;
+	dma->y_count       = 0;
+	dma->y_modify      = 0;
+
+	SSYNC();
+
+	return 0;
+}
+
+int bf53x_sport_rx_start(struct bf53x_sport *sport)
+{
+	unsigned long flags;
+
+	if (sport->rx_run)
+		return -EBUSY;
+
+	if (sport->tx_run) {
+		/* tx is running, rx is not running */
+		SPORT_ASSERT(sport->dma_rx_desc != NULL);
+		SPORT_ASSERT(sport->curr_rx_desc == sport->dummy_rx_desc);
+		local_irq_save(flags);
+		while ((get_dma_curr_desc_ptr(sport->dma_rx_chan) - \
+		        sizeof(struct dmasg)) != sport->dummy_rx_desc)
+			continue;
+		sport->dummy_rx_desc->next_desc_addr = sport->dma_rx_desc;
+		local_irq_restore(flags);
+		sport->curr_rx_desc = sport->dma_rx_desc;
+	} else {
+		sport_tx_dma_start(sport, 1);
+		sport_rx_dma_start(sport, 0);
+		sport_start(sport);
+	}
+
+	sport->rx_run = 1;
+
+	return 0;
+}
+
+int bf53x_sport_rx_stop(struct bf53x_sport *sport)
+{
+	if (!sport->rx_run)
+		return 0;
+
+	if (sport->tx_run) {
+		/* TX dma is still running, hook the dummy buffer */
+		sport_hook_rx_dummy(sport);
+	} else {
+		/* Both rx and tx dma will be stopped */
+		sport_stop(sport);
+		sport->curr_rx_desc = NULL;
+		sport->curr_tx_desc = NULL;
+	}
+
+	sport->rx_run = 0;
+
+	return 0;
+}
+
+static inline int sport_hook_tx_dummy(struct bf53x_sport *sport)
+{
+	struct dmasg *desc, temp_desc;
+	unsigned long flags;
+
+	SPORT_ASSERT(sport->dummy_tx_desc != NULL);
+	SPORT_ASSERT(sport->curr_tx_desc != sport->dummy_tx_desc);
+
+	sport->dummy_tx_desc->next_desc_addr = sport->dummy_tx_desc + 1;
+
+	/* Shorten the time on last normal descriptor */
+	local_irq_save(flags);
+	desc = (struct dmasg *)get_dma_next_desc_ptr(sport->dma_tx_chan);
+	/* Store the descriptor which will be damaged */
+	temp_desc = *desc;
+	desc->x_count = 0x10;
+	desc->y_count = 0;
+	desc->next_desc_addr = sport->dummy_tx_desc;
+	local_irq_restore(flags);
+	/* Waiting for dummy buffer descriptor is already hooked*/
+	while ((get_dma_curr_desc_ptr(sport->dma_tx_chan) - \
+	        sizeof(struct dmasg)) != sport->dummy_tx_desc)
+		continue;
+	sport->curr_tx_desc = sport->dummy_tx_desc;
+	/* Restore the damaged descriptor */
+	*desc = temp_desc;
+
+	return 0;
+}
+
+int bf53x_sport_tx_start(struct bf53x_sport *sport)
+{
+	unsigned long flags;
+
+	sport_printd(KERN_INFO, "%s: tx_run:%d, rx_run:%d\n",
+			__FUNCTION__, sport->tx_run, sport->rx_run);
+	if (sport->tx_run)
+		return -EBUSY;
+
+	if (sport->rx_run) {
+		SPORT_ASSERT(sport->dma_tx_desc != NULL);
+		SPORT_ASSERT(sport->curr_tx_desc == sport->dummy_tx_desc);
+		/* Hook the normal buffer descriptor */
+		local_irq_save(flags);
+		while ((get_dma_curr_desc_ptr(sport->dma_tx_chan) - \
+		       sizeof(struct dmasg)) != sport->dummy_tx_desc)
+			continue;
+		sport->dummy_tx_desc->next_desc_addr = sport->dma_tx_desc;
+		local_irq_restore(flags);
+		sport->curr_tx_desc = sport->dma_tx_desc;
+	} else {
+		sport_tx_dma_start(sport, 0);
+		/* Let rx dma run the dummy buffer */
+		sport_rx_dma_start(sport, 1);
+		sport_start(sport);
+	}
+	sport->tx_run = 1;
+
+	return 0;
+}
+
+int bf53x_sport_tx_stop(struct bf53x_sport *sport)
+{
+	if (!sport->tx_run)
+		return 0;
+
+	if (sport->rx_run) {
+		/* RX is still running, hook the dummy buffer */
+		sport_hook_tx_dummy(sport);
+	} else {
+		/* Both rx and tx dma stopped */
+		sport_stop(sport);
+		sport->curr_rx_desc = NULL;
+		sport->curr_tx_desc = NULL;
+	}
+
+	sport->tx_run = 0;
+
+	return 0;
+}
+
+static int inline compute_wdsize(size_t size)
+{
+	switch (size) {
+		case 1:
+			return WDSIZE_8;
+		case 2:
+			return WDSIZE_16;
+		case 4:
+		default:
+			return WDSIZE_32;
+	}
+}
+
+int bf53x_sport_config_rx_dma(struct bf53x_sport *sport, void *buf,
+		int fragcount, size_t fragsize, size_t size)
+{
+	unsigned int x_count;
+	unsigned int y_count;
+	unsigned int cfg;
+	dma_addr_t addr;
+
+	sport_printd(KERN_INFO, "%s( %p, %d, 0x%lx %ld )\n", __FUNCTION__, buf,
+			fragcount,fragsize, size);
+
+	x_count = fragsize / size;
+	y_count = 0;
+
+	/* for fragments larger than 64k words we use 2d dma,
+	 * denote fragecount as two numbers' mutliply and both of them
+	 * are less than 64k.*/
+	if (x_count >= 0x10000) {
+		int i, count=x_count;
+
+		for (i=16; i>0; i--) {
+			x_count = 1 << i;
+			if ((count & (x_count - 1)) == 0) {
+				y_count = count >> i;
+				if (y_count < 0x10000)
+					break;
+			}
+		}
+		if (i == 0)
+			return -EINVAL;
+	}
+	sport_printd(KERN_INFO, "%s(x_count:0x%x, y_count:0x%x)\n", __FUNCTION__,
+			x_count, y_count);
+
+	if (sport->dma_rx_desc) {
+		dma_free_coherent(NULL, sport->rx_desc_bytes, \
+				sport->dma_rx_desc, 0);
+	}
+
+	/* Allocate a new descritor ring as current one. */
+	sport->dma_rx_desc = dma_alloc_coherent(NULL, \
+			fragcount * sizeof(struct dmasg),	&addr, 0);
+	sport->rx_desc_bytes = fragcount * sizeof(struct dmasg);
+
+	if (!sport->dma_rx_desc) {
+		return -ENOMEM;
+	}
+
+	sport->rx_buf = buf;
+
+	cfg     = 0x7000 | DI_EN | compute_wdsize(size) | WNR | \
+		  (DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+
+	if (y_count != 0)
+		cfg |= DMA2D;
+
+	setup_desc(sport->dma_rx_desc, buf, fragcount, fragsize,
+			cfg|DMAEN, x_count, y_count, size);
+
+	return 0;
+}
+
+int bf53x_sport_config_tx_dma(struct bf53x_sport *sport, void *buf,
+		int fragcount, size_t fragsize, size_t size)
+{
+	unsigned int x_count;
+	unsigned int y_count;
+	unsigned int cfg;
+	dma_addr_t addr;
+
+	sport_printd(KERN_INFO, "%s( %p, %d, %lx, %lx )\n", __FUNCTION__, buf,
+			fragcount,fragsize, size);
+
+	x_count = fragsize/size;
+	y_count = 0;
+
+	/* for fragments larger than 64k words we use 2d dma,
+	 * denote fragecount as two numbers' mutliply and both of them
+	 * are less than 64k.*/
+	if (x_count >= 0x10000) {
+		int i, count = x_count;
+
+		for (i=16; i>0; i--) {
+			x_count = 1 << i;
+			if ((count & (x_count - 1)) == 0) {
+				y_count = count >> i;
+				if (y_count < 0x10000)
+					break;
+			}
+		}
+		if (i == 0)
+			return -EINVAL;
+	}
+	sport_printd(KERN_INFO, "%s(x_count:0x%x, y_count:0x%x)\n", __FUNCTION__,
+			x_count, y_count);
+
+
+	if (sport->dma_tx_desc) {
+		dma_free_coherent(NULL, sport->tx_desc_bytes, \
+				sport->dma_tx_desc, 0);
+	}
+
+	sport->dma_tx_desc = dma_alloc_coherent(NULL, \
+			fragcount * sizeof(struct dmasg), &addr, 0);
+	sport->tx_desc_bytes = fragcount * sizeof(struct dmasg);
+//	printk(KERN_ERR "alloc dma_tx_desc:0x%p, size:0x%x\n",
+//	sport->dma_tx_desc, sport->tx_desc_bytes);
+	if (!sport->dma_tx_desc) {
+		return -ENOMEM;
+	}
+
+	sport->tx_buf = buf;
+
+	cfg     = 0x7000 | DI_EN | compute_wdsize(size) | \
+		  (DESC_ELEMENT_COUNT << 8); /* large descriptor mode */
+
+	if (y_count != 0)
+		cfg |= DMA2D;
+
+	setup_desc(sport->dma_tx_desc, buf, fragcount, fragsize,
+			cfg|DMAEN, x_count, y_count, size);
+
+	return 0;
+}
+
+/* setup dummy dma descriptor ring, which don't generate interrupts,
+ * the x_modify is set to 0 */
+static int sport_config_rx_dummy(struct bf53x_sport *sport, size_t size)
+{
+	struct dma_register *dma;
+	struct dmasg *desc;
+	unsigned config;
+
+	sport_printd(KERN_INFO, "%s entered\n", __FUNCTION__);
+	dma = sport->dma_rx;
+#if L1_DATA_A_LENGTH != 0
+	desc = (struct dmasg*)l1_data_sram_alloc(2 * sizeof(*desc));
+#else
+	{
+		dma_addr_t addr;
+		desc = dma_alloc_coherent(NULL, 2 * sizeof(*desc), &addr, 0);
+	}
+#endif
+	if (desc == NULL)
+		return -ENOMEM;
+
+	memset(desc, 0, 2 * sizeof(*desc));
+	sport->dummy_rx_desc = desc;
+	desc->start_addr = (unsigned long)sport->dummy_buf;
+	config = DMAFLOW_LARGE | NDSIZE_9 | compute_wdsize(size) | WNR | DMAEN;
+	desc->cfg = config;
+	desc->x_count = 0x80;
+	desc->x_modify = 0;
+	desc->y_count = 0;
+	desc->y_modify = 0;
+	memcpy(desc+1, desc, sizeof(*desc));
+	desc->next_desc_addr = desc + 1;
+	desc[1].next_desc_addr = desc;
+
+	return 0;
+}
+
+static int sport_config_tx_dummy(struct bf53x_sport *sport, size_t size)
+{
+	struct dma_register *dma;
+	struct dmasg *desc;
+	unsigned int config;
+
+	sport_printd(KERN_INFO, "%s entered\n", __FUNCTION__);
+	dma = sport->dma_tx;
+
+#if L1_DATA_A_LENGTH != 0
+	desc = (struct dmasg*)l1_data_sram_alloc(2 * sizeof(*desc));
+#else
+	{
+		dma_addr_t addr;
+		desc = dma_alloc_coherent(NULL, 2*sizeof(*desc), &addr, 0);
+	}
+#endif
+	if (!desc)
+		return -ENOMEM;
+
+	memset(desc, 0, 2 * sizeof(*desc));
+	sport->dummy_tx_desc = desc;
+	desc->start_addr = (unsigned long)sport->dummy_buf + size;
+	config = DMAFLOW_LARGE | NDSIZE_9 | compute_wdsize(size) | DMAEN;
+	desc->cfg = config;
+	desc->x_count = 0x80;
+	desc->x_modify = 0;
+	desc->y_count = 0;
+	desc->y_modify = 0;
+	memcpy(desc+1, desc, sizeof(*desc));
+	desc->next_desc_addr = desc + 1;
+	desc[1].next_desc_addr = desc;
+
+	return 0;
+}
+
+unsigned long bf53x_sport_curr_offset_rx(struct bf53x_sport *sport)
+{
+	struct dma_register *dma = sport->dma_rx;
+	unsigned char *curr = *(unsigned char**) &(dma->curr_addr_ptr);
+	return (curr - sport->rx_buf);
+}
+
+unsigned long bf53x_sport_curr_offset_tx(struct bf53x_sport *sport)
+{
+	struct dma_register *dma = sport->dma_tx;
+	unsigned char *curr = *(unsigned char**) &(dma->curr_addr_ptr);
+	return (curr - sport->tx_buf);
+}
+
+static int sport_check_status(struct bf53x_sport *sport,
+		unsigned int *sport_stat,
+		unsigned int *rx_stat,
+		unsigned int *tx_stat)
+{
+	int status = 0;
+
+	if (sport_stat) {
+		SSYNC();
+		status = sport->regs->stat;
+		if (status & (TOVF|TUVF|ROVF|RUVF))
+			sport->regs->stat = (status & (TOVF|TUVF|ROVF|RUVF));
+		SSYNC();
+		*sport_stat = status;
+	}
+
+	if (rx_stat) {
+		SSYNC();
+		status = sport->dma_rx->irq_status;
+		if (status & (DMA_DONE|DMA_ERR))
+			sport->dma_rx->irq_status = status & (DMA_DONE|DMA_ERR);
+		SSYNC();
+		*rx_stat = status;
+	}
+
+	if (tx_stat) {
+		SSYNC();
+		status = sport->dma_tx->irq_status;
+		if (status & (DMA_DONE|DMA_ERR))
+			sport->dma_tx->irq_status = status & (DMA_DONE|DMA_ERR);
+		SSYNC();
+		*tx_stat = status;
+	}
+
+	return 0;
+}
+
+int  bf53x_sport_dump_stat(struct bf53x_sport *sport, char *buf, size_t len)
+{
+	int ret;
+
+	ret = snprintf(buf, len,
+			"sport  %d sts: 0x%04x\n"
+			"rx dma %d cfg: 0x%04x sts: 0x%04x\n"
+			"tx dma %d cfg: 0x%04x sts: 0x%04x\n",
+			sport->sport_num,  sport->regs->stat,
+			sport->dma_rx_chan, sport->dma_rx->cfg,
+			sport->dma_rx->irq_status,
+			sport->dma_tx_chan, sport->dma_tx->cfg,
+			sport->dma_tx->irq_status);
+	buf += ret;
+	len -= ret;
+
+	ret += snprintf(buf, len,
+			"curr_rx_desc:0x%p, curr_tx_desc:0x%p\n"
+			"dma_rx_desc:0x%p, dma_tx_desc:0x%p\n"
+			"dummy_rx_desc:0x%p, dummy_tx_desc:0x%p\n",
+			sport->curr_rx_desc, sport->curr_tx_desc,
+			sport->dma_rx_desc, sport->dma_tx_desc,
+			sport->dummy_rx_desc, sport->dummy_tx_desc);
+
+	return ret;
+}
+
+static irqreturn_t rx_handler(int irq, void *dev_id)
+{
+	unsigned int rx_stat;
+	struct bf53x_sport *sport = dev_id;
+
+//	sport_printd(KERN_INFO, "%s\n", __FUNCTION__);
+	sport_check_status(sport, NULL, &rx_stat, NULL);
+	if (!(rx_stat & DMA_DONE)) {
+		printk(KERN_ERR "rx dma is already stopped\n");
+	}
+	if (sport->rx_callback) {
+		sport->rx_callback(sport->data);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static irqreturn_t tx_handler(int irq, void *dev_id)
+{
+	unsigned int tx_stat;
+	struct bf53x_sport *sport = dev_id;
+
+//	sport_printd(KERN_INFO, "%s\n", __FUNCTION__);
+	sport_check_status(sport, NULL, NULL, &tx_stat);
+	if (!(tx_stat & DMA_DONE)) {
+		printk(KERN_ERR "tx dma is already stopped\n");
+		return IRQ_HANDLED;
+	}
+
+	if (sport->tx_callback) {
+		sport->tx_callback(sport->data);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static irqreturn_t err_handler(int irq, void *dev_id)
+{
+	unsigned int status;
+	struct bf53x_sport *sport = dev_id;
+
+	sport_printd(KERN_INFO, "%s\n", __FUNCTION__);
+	if (sport_check_status(sport, &status, NULL, NULL)) {
+		printk(KERN_ERR "error checking status ??");
+		return IRQ_NONE;
+	}
+
+	if (status & (TOVF|TUVF|ROVF|RUVF)) {
+		printk(KERN_INFO  "sport status error:%s%s%s%s\n",
+				status & TOVF ? " TOVF" : "",
+				status & TUVF ? " TUVF" : "",
+				status & ROVF ? " ROVF" : "",
+				status & RUVF ? " RUVF" : "");
+		if (status & TOVF || status & TUVF) {
+			disable_dma(sport->dma_tx_chan);
+			sport_tx_dma_start(sport, 0);
+			enable_dma(sport->dma_tx_chan);
+		} else {
+			disable_dma(sport->dma_rx_chan);
+			sport_rx_dma_start(sport, 0);
+			enable_dma(sport->dma_rx_chan);
+		}
+	}
+	status = sport->regs->stat;
+	if (status & (TOVF|TUVF|ROVF|RUVF)) {
+		sport->regs->stat = (status & (TOVF|TUVF|ROVF|RUVF));
+		SSYNC();
+
+		if (sport->err_callback)
+			sport->err_callback(sport->data);
+	}
+	return IRQ_HANDLED;
+}
+
+struct bf53x_sport *bf53x_sport_init(int sport_num,
+		int dma_rx, void (*rx_callback)(void*),
+		int dma_tx, void (*tx_callback)(void*),
+		int err_irq, void (*err_callback)(void*),
+		size_t size, void *data)
+{
+	struct bf53x_sport *sport;
+
+	sport = kmalloc(sizeof(struct bf53x_sport), GFP_KERNEL);
+
+	if (!sport)
+		return NULL;
+
+	SPORT_ASSERT(sizeof(struct sport_register) == 0x60);
+
+	memset(sport, 0, sizeof(struct bf53x_sport));
+	sport->sport_num = sport_num;
+	sport->regs = (struct sport_register*) sport_iobase[sport_num];
+
+	if (request_dma(dma_rx, "SPORT RX Data") == -EBUSY) {
+		printk(KERN_ERR "Failed to request RX dma %d\n", dma_rx);
+		goto __init_err1;
+	}
+
+	if (set_dma_callback(dma_rx, rx_handler, sport) != 0) {
+		printk(KERN_ERR "Failed to request RX irq %d\n", dma_rx);
+		goto __init_err2;
+	}
+
+	if (request_dma(dma_tx, "SPORT TX Data") == -EBUSY) {
+		printk(KERN_ERR "Failed to request TX dma %d\n", dma_tx);
+		goto __init_err2;
+	}
+
+	if (set_dma_callback(dma_tx, tx_handler, sport) != 0) {
+		printk(KERN_ERR "Failed to request TX irq %d\n", dma_tx);
+		goto __init_err3;
+	}
+
+	if (request_irq(err_irq, err_handler, IRQF_SHARED, "SPORT error",
+			sport) < 0) {
+		printk(KERN_ERR "Failed to request err irq:%d\n", err_irq);
+		goto __init_err3;
+	}
+
+	sport->dma_rx_chan = dma_rx;
+	sport->dma_rx = dma_io_base_addr[dma_rx];
+	sport->dma_tx_chan = dma_tx;
+	sport->dma_tx = dma_io_base_addr[dma_tx];
+	sport->err_irq = err_irq;
+	sport->rx_callback = rx_callback;
+	sport->tx_callback = tx_callback;
+	sport->err_callback = err_callback;
+	sport->data = data;
+
+	sport_printd(KERN_INFO, "%p dma rx: %p tx: %p\n",
+			sport->regs, sport->dma_rx, sport->dma_tx);
+
+#if L1_DATA_A_LENGTH != 0
+	sport->dummy_buf = l1_data_sram_alloc(size * 2);
+#else
+	sport->dummy_buf = kmalloc(size * 2, GFP_KERNEL);
+#endif
+	if (sport->dummy_buf == NULL) {
+		printk(KERN_ERR "Failed to allocate dummy buffer\n");
+		goto __init_err4;
+ 	}
+
+	memset(sport->dummy_buf, 0, size * 2);
+	sport_config_rx_dummy(sport, size);
+	sport_config_tx_dummy(sport, size);
+
+	if (sport->sport_num) {
+		if (peripheral_request_list(bfin_snd_pin_req_sport1, DRV_NAME))
+			goto __init_err5;
+	} else {
+		if (peripheral_request_list(bfin_snd_pin_req_sport0, DRV_NAME))
+			goto __init_err5;
+	}
+
+	return sport;
+
+__init_err5:
+#if L1_DATA_A_LENGTH != 0
+	l1_data_sram_free(sport->dummy_buf);
+#else
+	kfree(sport->dummy_buf);
+#endif
+	printk(KERN_ERR DRV_NAME
+		": Requesting Peripherals failed\n");
+
+__init_err4:
+	free_irq(sport->err_irq, sport);
+__init_err3:
+	free_dma(sport->dma_tx_chan);
+__init_err2:
+	free_dma(sport->dma_rx_chan);
+__init_err1:
+	kfree(sport);
+	return NULL;
+}
+
+void bf53x_sport_done(struct bf53x_sport *sport)
+{
+	if (sport == NULL)
+		return;
+
+	sport_stop(sport);
+
+	if (sport->sport_num) {
+		peripheral_free_list(bfin_snd_pin_req_sport1);
+	} else {
+		peripheral_free_list(bfin_snd_pin_req_sport0);
+	}
+
+	if (sport->dma_rx_desc)
+		dma_free_coherent(NULL, sport->rx_desc_bytes, \
+				sport->dma_rx_desc, 0);
+	if (sport->dma_tx_desc)
+		dma_free_coherent(NULL, sport->tx_desc_bytes, \
+				sport->dma_tx_desc, 0);
+
+#if L1_DATA_A_LENGTH != 0
+	l1_data_sram_free(sport->dummy_rx_desc);
+	l1_data_sram_free(sport->dummy_tx_desc);
+	l1_data_sram_free(sport->dummy_buf);
+#else
+	dma_free_coherent(NULL, 2*sizeof(struct dmasg), sport->dummy_rx_desc, 0);
+	dma_free_coherent(NULL, 2*sizeof(struct dmasg), sport->dummy_tx_desc, 0);
+	kfree(sport->dummy_buf);
+#endif
+	free_dma(sport->dma_rx_chan);
+	free_dma(sport->dma_tx_chan);
+	free_irq(sport->err_irq, sport);
+
+	kfree(sport);
+}
diff --git a/sound/blackfin/bf53x_sport.h b/sound/blackfin/bf53x_sport.h
new file mode 100644
index 0000000..e90dc16
--- /dev/null
+++ b/sound/blackfin/bf53x_sport.h
@@ -0,0 +1,129 @@
+/*
+ * File:         sound/blackfin/bf53x_sport.h
+ * Based on:
+ * Author:       Luuk van Dijk <blackfin@mdnmttr.nl>
+ *
+ * Created:      Tue Sep 21 10:52:42 CEST 2004
+ * Description:  low level driver for sportX/dmaY on blackfin 53x
+ *               this should be moved to arch/blackfin/
+ *
+ * Modified:
+ *               Copyright 2004-2006 Analog Devices Inc.
+ *
+ * Bugs:         Enter bugs at http://blackfin.uclinux.org/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see the file COPYING, or write
+ * to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __BF53X_SPORT_H__
+#define __BF53X_SPORT_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <asm/bfin_sport.h>
+#include <asm/dma.h>
+
+#define DESC_ELEMENT_COUNT 9
+
+struct bf53x_sport {
+	int sport_num;
+	int dma_rx_chan;
+	int dma_tx_chan;
+	int err_irq;
+	struct sport_register* regs;
+
+	struct dma_register *dma_rx;
+	struct dma_register *dma_tx;
+	unsigned char *rx_buf;
+	unsigned char *tx_buf;
+
+	/* for dummy dma transfer */
+	void *dummy_buf;
+
+	/* DMA descriptor ring head of current audio stream*/
+	struct dmasg *dma_rx_desc;
+	struct dmasg *dma_tx_desc;
+	unsigned int rx_desc_bytes;
+	unsigned int tx_desc_bytes;
+
+	unsigned int rx_run:1; /* rx is running */
+	unsigned int tx_run:1; /* tx is running */
+
+	struct dmasg *dummy_rx_desc;
+	struct dmasg *dummy_tx_desc;
+
+	struct dmasg *curr_rx_desc;
+	struct dmasg *curr_tx_desc;
+
+	unsigned int rcr1;
+	unsigned int rcr2;
+	int rx_tdm_count;
+
+	unsigned int tcr1;
+	unsigned int tcr2;
+	int tx_tdm_count;
+
+	void (*rx_callback)(void *data);
+	void (*tx_callback)(void *data);
+	void (*err_callback)(void *data);
+	void *data;
+};
+
+struct bf53x_sport* bf53x_sport_init(int sport_num,
+		int dma_rx, void (*rx_callback)(void *),
+		int dma_tx, void (*tx_callback)(void *),
+		int err_irq, void (*err_callback)(void *),
+		size_t size, void *data);
+
+void bf53x_sport_done(struct bf53x_sport* sport);
+
+/* first use these ...*/
+
+/* note: multichannel is in units of 8 channels, tdm_count is # channels NOT / 8 ! */
+/* all channels are enabled by default */
+int bf53x_sport_set_multichannel(struct bf53x_sport* sport, int tdm_count, int packed);
+
+int bf53x_sport_config_rx(struct bf53x_sport* sport,
+		unsigned int rcr1, unsigned int rcr2,
+		unsigned int clkdiv, unsigned int fsdiv);
+
+int bf53x_sport_config_tx(struct bf53x_sport* sport,
+		unsigned int tcr1, unsigned int tcr2,
+		unsigned int clkdiv, unsigned int fsdiv);
+
+/* ... then these: */
+
+/* buffer size (in bytes) == fragcount * fragsize_bytes */
+
+/* this is not a very general api, it sets the dma to 2d autobuffer mode */
+
+int bf53x_sport_config_rx_dma(struct bf53x_sport* sport, void* buf,
+		int fragcount, size_t fragsize_bytes, size_t size);
+
+int bf53x_sport_config_tx_dma(struct bf53x_sport* sport, void* buf,
+		int fragcount, size_t fragsize_bytes, size_t size);
+
+int bf53x_sport_tx_start(struct bf53x_sport* sport);
+int bf53x_sport_tx_stop(struct bf53x_sport* sport);
+int bf53x_sport_rx_start(struct bf53x_sport* sport);
+int bf53x_sport_rx_stop(struct bf53x_sport* sport);
+
+/* for use in interrupt handler */
+unsigned long bf53x_sport_curr_offset_rx(struct bf53x_sport* sport);
+unsigned long bf53x_sport_curr_offset_tx(struct bf53x_sport* sport);
+
+#endif /* BF53X_SPORT_H */
-- 
1.7.0.2

