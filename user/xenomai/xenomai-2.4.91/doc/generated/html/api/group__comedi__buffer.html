<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Buffer management services</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Buffer management services<br>
<small>
[<a class="el" href="group__driverfacilities.html">Driver API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Buffer management services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__comedi__buffer.png" border="0" alt="" usemap="#group____comedi____buffer_map">
<map name="group____comedi____buffer_map">
<area shape="rect" href="group__driverfacilities.html" title="Driver API." alt="" coords="5,5,91,32"></map></td></tr></table></center>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#g41beae7a1985601dbb6296cf68a85872">comedi_buf_prepare_absput</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot.  <a href="#g41beae7a1985601dbb6296cf68a85872"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#g7bb612805b505869f2294fee5ba55851">comedi_buf_commit_absput</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot.  <a href="#g7bb612805b505869f2294fee5ba55851"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gda44d403d8be30ad8f12db26f92eb75f">comedi_buf_prepare_put</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data which is to be sent to the buffer at the next DMA shot.  <a href="#gda44d403d8be30ad8f12db26f92eb75f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gc24e9b79e5bf3198098df3a53c1aa064">comedi_buf_commit_put</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data sent to the buffer during the last completed DMA shots.  <a href="#gc24e9b79e5bf3198098df3a53c1aa064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#g826875d8fdfa2f1e685dcef5f73fc5ee">comedi_buf_put</a> (comedi_dev_t *dev, void *bufdata, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy some data from the device driver to the buffer.  <a href="#g826875d8fdfa2f1e685dcef5f73fc5ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gbdb7f3521ba224db14bb069d7a6cdf38">comedi_buf_prepare_absget</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot.  <a href="#gbdb7f3521ba224db14bb069d7a6cdf38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#g43995ef0f5412e85292d1ae092295641">comedi_buf_commit_absget</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot.  <a href="#g43995ef0f5412e85292d1ae092295641"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#g92f87711d131f2d97f971d0b6bb0b675">comedi_buf_prepare_get</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data which is to be sent from the buffer to the device at the next DMA shot.  <a href="#g92f87711d131f2d97f971d0b6bb0b675"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gc60051e47ffeaeb56232e919d9db92b0">comedi_buf_commit_get</a> (comedi_dev_t *dev, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data sent from the buffer to the device during the last completed DMA shots.  <a href="#gc60051e47ffeaeb56232e919d9db92b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gd38dee7ca3637248289c35e664e1d106">comedi_buf_get</a> (comedi_dev_t *dev, void *bufdata, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy some data from the buffer to the device driver.  <a href="#gd38dee7ca3637248289c35e664e1d106"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gc1f1c9241b07f227962739fec1f7934c">comedi_buf_evt</a> (comedi_dev_t *dev, unsigned int type, unsigned long evts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal some event(s) to a uer-space program involved in some read / write operation.  <a href="#gc1f1c9241b07f227962739fec1f7934c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#ge7f635ec9e11f62c41d5d0e39bbb3b2d">comedi_buf_count</a> (comedi_dev_t *dev, unsigned int type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data amount available in the Comedi buffer.  <a href="#ge7f635ec9e11f62c41d5d0e39bbb3b2d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcomedi__cmd__desc.html">comedi_cmd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gac6511221868aa7f9e736051228fc6b6">comedi_get_cmd</a> (comedi_dev_t *dev, unsigned int type, int idx_subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current Comedi command descriptor.  <a href="#gac6511221868aa7f9e736051228fc6b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__comedi__buffer.html#gdaa1225e24070d8f39a5e490bb8984b8">comedi_get_chan</a> (struct comedi_device *dev, unsigned int type, int idx_subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the channel index according to its type.  <a href="#gdaa1225e24070d8f39a5e490bb8984b8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Buffer management services<p>
The buffer is the key component of the Comedi infrastructure. It manages transfers between the user-space and the Comedi drivers thanks to generic functions which are described hereafter. Thanks to the buffer subsystem, the driver developer does not have to care about the way the user program retrieves or sends data.<p>
To write a classical char driver, the developer has to fill a fops structure so as to provide transfer operations to the user program (read, write, ioctl and mmap if need be).<p>
The Comedi infrastructure manages the whole interface with the userspace; the common read, write, mmap, etc. callbacks are generic Comedi functions. These functions manage (and perform, if need be) tranfers between the user-space and an asynchronous buffer thanks to lockless mechanisms.<p>
Consequently, the developer has to use the proper buffer functions in order to write / read acquired data into / from the asynchronous buffer.<p>
Here are listed the functions:<ul>
<li>comedi_buf_prepare_(abs)put() and comedi_buf_commit_(abs)put()</li><li>comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get()</li><li><a class="el" href="group__comedi__buffer.html#g826875d8fdfa2f1e685dcef5f73fc5ee" title="Copy some data from the device driver to the buffer.">comedi_buf_put()</a></li><li><a class="el" href="group__comedi__buffer.html#gd38dee7ca3637248289c35e664e1d106" title="Copy some data from the buffer to the device driver.">comedi_buf_get()</a></li><li><a class="el" href="group__comedi__buffer.html#gc1f1c9241b07f227962739fec1f7934c" title="Signal some event(s) to a uer-space program involved in some read / write operation...">comedi_buf_evt()</a>.</li></ul>
<p>
The functions count might seem high; however, the developer needs a few of them to write a driver. Having so many functions enables to manage any transfer cases:<ul>
<li>If some DMA controller is available, there is no need to make the driver copy the acquired data into the asynchronous buffer, the DMA controller must directly trigger DMA shots into / from the buffer. In that case, a function comedi_buf_prepare_*() must be used so as to set up the DMA transfer and a function comedi_buf_commit_*() has to be called to complete the transfer().</li><li>For DMA controllers which need to work with global counter (the transfered data count since the beginning of the acquisition), the functions comedi_buf_*_abs_*() have been made available.</li><li>If no DMA controller is available, the driver has to perform the copy between the hardware component and the asynchronous buffer. In such cases, the functions <a class="el" href="group__comedi__buffer.html#gd38dee7ca3637248289c35e664e1d106" title="Copy some data from the buffer to the device driver.">comedi_buf_get()</a> and <a class="el" href="group__comedi__buffer.html#g826875d8fdfa2f1e685dcef5f73fc5ee" title="Copy some data from the device driver to the buffer.">comedi_buf_put()</a> are useful. </li></ul>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g43995ef0f5412e85292d1ae092295641"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_commit_absget" ref="g43995ef0f5412e85292d1ae092295641" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_commit_absget           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count transferred to the device during the last DMA shot plus the data count which have been sent since the beginning of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7bb612805b505869f2294fee5ba55851"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_commit_absput" ref="g7bb612805b505869f2294fee5ba55851" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_commit_absput           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count transferred to the buffer during the last DMA shot plus the data count which have been sent / retrieved since the beginning of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc60051e47ffeaeb56232e919d9db92b0"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_commit_get" ref="gc60051e47ffeaeb56232e919d9db92b0" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_commit_get           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data sent from the buffer to the device during the last completed DMA shots. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc24e9b79e5bf3198098df3a53c1aa064"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_commit_put" ref="gc24e9b79e5bf3198098df3a53c1aa064" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_commit_put           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data sent to the buffer during the last completed DMA shots. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge7f635ec9e11f62c41d5d0e39bbb3b2d"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_count" ref="ge7f635ec9e11f62c41d5d0e39bbb3b2d" args="(comedi_dev_t *dev, unsigned int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long comedi_buf_count           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the data amount available in the Comedi buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Buffer transfer type:<ul>
<li>COMEDI_BUF_PUT for device -&gt; Comedi buffer -&gt; user-process transfer; in this case, the returned count is the free space in the Comedi buffer in which the driver can put acquired data.</li><li>COMEDI_BUF_GET for user-process -&gt; Comedi_buffer -&gt; device transfer; in that case, the returned count is the data amount available for sending to the device.</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the amount of data available in the Comedi buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc1f1c9241b07f227962739fec1f7934c"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_evt" ref="gc1f1c9241b07f227962739fec1f7934c" args="(comedi_dev_t *dev, unsigned int type, unsigned long evts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_evt           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>evts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal some event(s) to a uer-space program involved in some read / write operation. 
<p>
The function <a class="el" href="group__comedi__buffer.html#gc1f1c9241b07f227962739fec1f7934c" title="Signal some event(s) to a uer-space program involved in some read / write operation...">comedi_buf_evt()</a> is useful in many cases:<ul>
<li>To wake-up a process waiting for some data to read.</li><li>To wake-up a process waiting for some data to write.</li><li>To notify the user-process an error has occured during the acquistion.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Buffer transfer type:<ul>
<li>COMEDI_BUF_PUT for device -&gt; Comedi buffer -&gt; user-process transfer.</li><li>COMEDI_BUF_GET for user-process -&gt; Comedi_buffer -&gt; device transfer </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evts</em>&nbsp;</td><td>Some specific event to notify:<ul>
<li>COMEDI_BUF_ERROR to indicate some error has occured during the transfer</li><li>COMEDI_BUF_EOA to indicate the acquisition is complete (this event is automatically set, it should not be used).</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd38dee7ca3637248289c35e664e1d106"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_get" ref="gd38dee7ca3637248289c35e664e1d106" args="(comedi_dev_t *dev, void *bufdata, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_get           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy some data from the buffer to the device driver. 
<p>
The function <a class="el" href="group__comedi__buffer.html#gd38dee7ca3637248289c35e664e1d106" title="Copy some data from the buffer to the device driver.">comedi_buf_get()</a> must copy data coming from the Comedi buffer to some acquisition device. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to provide the data to send to the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufdata</em>&nbsp;</td><td>The data buffer to copy into the Comedi buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data to copy</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbdb7f3521ba224db14bb069d7a6cdf38"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_prepare_absget" ref="gbdb7f3521ba224db14bb069d7a6cdf38" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_prepare_absget           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g41beae7a1985601dbb6296cf68a85872"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_prepare_absput" ref="g41beae7a1985601dbb6296cf68a85872" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_prepare_absput           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g92f87711d131f2d97f971d0b6bb0b675"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_prepare_get" ref="g92f87711d131f2d97f971d0b6bb0b675" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_prepare_get           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data which is to be sent from the buffer to the device at the next DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gda44d403d8be30ad8f12db26f92eb75f"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_prepare_put" ref="gda44d403d8be30ad8f12db26f92eb75f" args="(comedi_dev_t *dev, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_prepare_put           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data which is to be sent to the buffer at the next DMA shot. 
<p>
The functions comedi_buf_prepare_(abs)put(), comedi_buf_commit_(abs)put(), comedi_buf_prepare_(abs)get() and comedi_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Comedi buffer and the device as some DMA controller is in charge of performing data shots from / to the Comedi buffer. However, some pointers stil have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g826875d8fdfa2f1e685dcef5f73fc5ee"></a><!-- doxytag: member="driver_facilities.c::comedi_buf_put" ref="g826875d8fdfa2f1e685dcef5f73fc5ee" args="(comedi_dev_t *dev, void *bufdata, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_buf_put           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy some data from the device driver to the buffer. 
<p>
The function <a class="el" href="group__comedi__buffer.html#g826875d8fdfa2f1e685dcef5f73fc5ee" title="Copy some data from the device driver to the buffer.">comedi_buf_put()</a> must copy data coming from some acquisition device to the Comedi buffer. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to recover the acquired data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufdata</em>&nbsp;</td><td>The data buffer to copy into the Comedi buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data to copy</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdaa1225e24070d8f39a5e490bb8984b8"></a><!-- doxytag: member="driver_facilities.c::comedi_get_chan" ref="gdaa1225e24070d8f39a5e490bb8984b8" args="(struct comedi_device *dev, unsigned int type, int idx_subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int comedi_get_chan           </td>
          <td>(</td>
          <td class="paramtype">struct comedi_device *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx_subd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the channel index according to its type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Buffer transfer type:<ul>
<li>COMEDI_BUF_PUT for device -&gt; Comedi buffer -&gt; user-process transfer.</li><li>COMEDI_BUF_GET for user-process -&gt; Comedi_buffer -&gt; device transfer. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx_subd</em>&nbsp;</td><td>Subdevice key index; this argument is optional: if the "type" is not correct, the last argument is used to select the proper subdevice.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the channel index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gac6511221868aa7f9e736051228fc6b6"></a><!-- doxytag: member="driver_facilities.c::comedi_get_cmd" ref="gac6511221868aa7f9e736051228fc6b6" args="(comedi_dev_t *dev, unsigned int type, int idx_subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomedi__cmd__desc.html">comedi_cmd_t</a>* comedi_get_cmd           </td>
          <td>(</td>
          <td class="paramtype">comedi_dev_t *&nbsp;</td>
          <td class="paramname"> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>idx_subd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current Comedi command descriptor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev</em>&nbsp;</td><td>Device descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Buffer transfer type:<ul>
<li>COMEDI_BUF_PUT for device -&gt; Comedi buffer -&gt; user-process transfer.</li><li>COMEDI_BUF_GET for user-process -&gt; Comedi_buffer -&gt; device transfer. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idx_subd</em>&nbsp;</td><td>Subdevice key index; this argument is optional: if the "type" is not correct, the last argument is used to select the proper subdevice.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the command descriptor. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 18 13:51:04 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
